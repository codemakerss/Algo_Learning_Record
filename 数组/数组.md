#  数组相关内容合集

## 二分查找

核心代码：LeetCode：704. 二分查找

```java
// 左闭右闭
public int search(int[] nums, int target) {
      int left = 0;
      int right = nums.length - 1;
      while (left <= right){
          int middle =  left + ((right - left) / 2);
          if (nums[middle] > target){
              right = middle - 1;
          }else if (nums[middle] < target){
              left = middle + 1;
          }else{
              return middle;
          }
      }
      return -1;

}

// 左闭右开
public int search(int[] nums, int target) {
      int left = 0;
      int right = nums.length1;
      while (left <= right){
          int middle =  left + ((right - left) / 2);
          if (nums[middle] > target){
              right = middle;
          }else if (nums[middle] < target){
              left = middle + 1;
          }else{
              return middle;
          }
      }
      return -1;

}
```

相关题目：

- [35.搜索插入位置](https://programmercarl.com/0035.搜索插入位置.html)

  ```java
  class Solution {
      public int searchInsert(int[] nums, int target) {
          int left = 0;
          int right = nums.length - 1;
          while (left <= right){
              int mid = left + (right -left) / 2;
              if (nums[mid] < target){
                  left = mid +1;
              }else if(nums[mid] > target){
                  right = mid - 1;
              }else{
                  return mid;
              }
          }
          return left;
          
      }
  }
  ```

  

- [34.在排序数组中查找元素的第一个和最后一个位置](https://programmercarl.com/0034.在排序数组中查找元素的第一个和最后一个位置.html)

  ```java
  class Solution {
      public int[] searchRange(int[] nums, int target) {
          int left = 0;
          int right = nums.length -1;
          if (right == 0 && nums[0] == target){
              return new int[]{0,0};
          }
          while (left <= right){
              int mid = left + (right - left) / 2;
              if (nums[mid] > target){
                  right = mid - 1;
                  // System.out.println(nums[right]);
              }else if (nums[mid] < target){
                  left = left + 1;
              }else{
                  // System.out.println(mid);
                  if (nums[mid] != nums[mid+1]){
                      return new int[]{mid,mid};
                  }
                  return new int[]{mid, mid+1};
              }
          }
          return new int[]{-1,-1};
      }
  }
  ```

  

- [69.x 的平方根](https://leetcode.cn/problems/sqrtx/)

  ```java
  class Solution {
      public int mySqrt(int x) {
          int left = 0;
          int right = x;
          int ans = -1;
          while (left <= right){
              int mid = left + (right - left) / 2;
              if ((long) mid*mid <= x){ // such as 8 has decimals
                  ans = mid;
                  left = mid + 1;
              }else{
                  right = mid - 1; 
              }
          }
          return ans;
      }
  }
  ```

  

- [367.有效的完全平方数](https://leetcode.cn/problems/valid-perfect-square/)

  ```java
  class Solution {
      public boolean isPerfectSquare(int num) {
          int left = 0;
          int right = num;
          while (left <= right) {
              int mid = left + (right - left) / 2;
              long square = (long)mid * mid;  // 使用long避免溢出
              if (square < num) {
                  left = mid + 1;
              } else if (square > num) {
                  right = mid - 1;    // 修正这里
              } else {
                  return true;
              }
          }
          return false;
      }
  ```

  

## 移除元素

核心代码：LeetCode：27. 移除元素

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int slow = 0;
        for (int fast=0;fast < nums.length;fast++){
            if (nums[fast] != val){
                nums[slow] = nums[fast];
                slow++;
            }
        }
        return slow;
    }
}
```

相关题目：

- [26.删除排序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

  ```java
  class Solution {
      public int removeDuplicates(int[] nums) {
          int slow = 0;
          for (int right=0;right < nums.length; right++){
              if (nums[right] != nums[slow]){
                  slow++; // 说明前两个是一样的，只更新后面那个即可
                  nums[slow] = nums[right];
                  // slow++;
              }
          }
          return slow+1; //数组长度为索引+1
      }
  }
  ```

  

- [283.移动零](https://leetcode.cn/problems/move-zeroes/)

  ```java
  class Solution {
      public void moveZeroes(int[] nums) {
          int left = 0;
          for (int right = 0; right < nums.length; right++){
              if (nums[right] != 0){
                  nums[left] = nums[right];
                  left++;
              }
          }
          for (int i=left;i<nums.length;i++){
              // System.out.println(i);
              nums[i] = 0;
          }
          // System.out.println(nums);
      }
  }
  ```

  

- [844.比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)

  ```java
  class Solution {
      public boolean backspaceCompare(String s, String t) {
      
          return backCompare(s).equals(backCompare(t));
     
          
      }
      private String backCompare(String s){
          int left = 0;
          char[] tmp = s.toCharArray();
  
          for (int right=0;right<s.length();right++){
              if (tmp[right] != '#'){
                  tmp[left] = tmp[right];
                  left++;
              }else if (left > 0){
                  left--;
              }
          }
          return new String(tmp,0,left);
      }
  }
  ```

  

- [977.有序数组的平方(opens new window)](https://leetcode.cn/problems/squares-of-a-sorted-array/)

  ```java
  import java.util.ArrayList;
  import java.util.Arrays;
  import java.util.List;
  
  // 暴力解法
  class Solution {
      public int[] sortedSquares(int[] nums) {
          List<Integer> ans = new ArrayList<>();
          for (int i:nums){
              ans.add(i*i);
          }
          
          int[] anss = new int[nums.length];
          for (int i =0;i<nums.length;i++){
              anss[i] = ans.get(i);
          }
          Arrays.sort(anss);
          return anss;
      }
  }
  
  // 双指针解法
  public int[] sortedSquares(int[] nums) {
          int[] result = new int[nums.length];
          int left = 0;
          int right = nums.length - 1;
          int index = nums.length - 1;
          while (left <= right) {
              if (nums[left]*nums[left] > nums[right] * nums[right]){
                  result[index] = nums[left] * nums[left];
                  left++;
                  index--;
              }else{
                  result[index] = nums[right] * nums[right];
                  right--;
                  index--;
              }
          }
          return result;
  }
  ```

  

## 长度最小的子数组

核心代码：LeetCode：209.长度最小的子数组

```java
// 滑动窗口
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int i = 0;
        int result = 1000000001;
        int sum = 0;
        for (int end=0;end<nums.length;end++){
            sum += nums[end];
            // 符合条件 - 持续移动
            while (sum >= target){
                int tmpLen = end - i + 1;
                result = Math.min(result, tmpLen);
                // 收缩区间
                sum -= nums[i];
                // 起始位置往前移
                i++;
            }
        }
        return result == 1000000001 ? 0 : result;
        
    }
}
```

