#  数组相关内容合集

## 二分查找

##### 核心代码：LeetCode：704. 二分查找

```java
// 左闭右闭
public int search(int[] nums, int target) {
      int left = 0;
      int right = nums.length - 1;
      while (left <= right){
          int middle =  left + ((right - left) / 2);
          if (nums[middle] > target){
              right = middle - 1;
          }else if (nums[middle] < target){
              left = middle + 1;
          }else{
              return middle;
          }
      }
      return -1;

}

// 左闭右开
public int search(int[] nums, int target) {
      int left = 0;
      int right = nums.length1;
      while (left < right){
          int middle =  left + ((right - left) / 2);
          if (nums[middle] > target){
              right = middle;
          }else if (nums[middle] < target){
              left = middle + 1;
          }else{
              return middle;
          }
      }
      return -1;

}
```

相关题目：

##### [35.搜索插入位置](https://programmercarl.com/0035.搜索插入位置.html)

  ```java
  class Solution {
      public int searchInsert(int[] nums, int target) {
          int left = 0;
          int right = nums.length - 1;
          while (left <= right){
              int mid = left + (right -left) / 2;
              if (nums[mid] < target){
                  left = mid +1;
              }else if(nums[mid] > target){
                  right = mid - 1;
              }else{
                  return mid;
              }
          }
          return left;
          
      }
  }
  ```

  

##### [34.在排序数组中查找元素的第一个和最后一个位置](https://programmercarl.com/0034.在排序数组中查找元素的第一个和最后一个位置.html)

  ```java
  class Solution {
      public int[] searchRange(int[] nums, int target) {
          int left = 0;
          int right = nums.length -1;
          if (right == 0 && nums[0] == target){
              return new int[]{0,0};
          }
          while (left <= right){
              int mid = left + (right - left) / 2;
              if (nums[mid] > target){
                  right = mid - 1;
                  // System.out.println(nums[right]);
              }else if (nums[mid] < target){
                  left = left + 1;
              }else{
                  // System.out.println(mid);
                  if (nums[mid] != nums[mid+1]){
                      return new int[]{mid,mid};
                  }
                  return new int[]{mid, mid+1};
              }
          }
          return new int[]{-1,-1};
      }
  }
  ```

  

##### [69.x 的平方根](https://leetcode.cn/problems/sqrtx/)

  ```java
  class Solution {
      public int mySqrt(int x) {
          int left = 0;
          int right = x;
          int ans = -1;
          while (left <= right){
              int mid = left + (right - left) / 2;
              if ((long) mid*mid <= x){ // such as 8 has decimals
                  ans = mid;
                  left = mid + 1;
              }else{
                  right = mid - 1; 
              }
          }
          return ans;
      }
  }
  ```

  

##### [367.有效的完全平方数](https://leetcode.cn/problems/valid-perfect-square/)

  ```java
  class Solution {
      public boolean isPerfectSquare(int num) {
          int left = 0;
          int right = num;
          while (left <= right) {
              int mid = left + (right - left) / 2;
              long square = (long)mid * mid;  // 使用long避免溢出
              if (square < num) {
                  left = mid + 1;
              } else if (square > num) {
                  right = mid - 1;    // 修正这里
              } else {
                  return true;
              }
          }
          return false;
      }
  ```

  

## 移除元素

##### 核心代码：LeetCode：27. 移除元素

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int slow = 0;
        for (int fast=0;fast < nums.length;fast++){
            if (nums[fast] != val){
                nums[slow] = nums[fast];
                slow++;
            }
        }
        return slow;
    }
}
```

相关题目：

##### [26.删除排序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

  ```java
  class Solution {
      public int removeDuplicates(int[] nums) {
          int slow = 0;
          for (int right=0;right < nums.length; right++){
              if (nums[right] != nums[slow]){
                  slow++; // 说明前两个是一样的，只更新后面那个即可
                  nums[slow] = nums[right];
                  // slow++;
              }
          }
          return slow+1; //数组长度为索引+1
      }
  }
  ```

  

##### [283.移动零](https://leetcode.cn/problems/move-zeroes/)

  ```java
  class Solution {
      public void moveZeroes(int[] nums) {
          int left = 0;
          for (int right = 0; right < nums.length; right++){
              if (nums[right] != 0){
                  nums[left] = nums[right];
                  left++;
              }
          }
          for (int i=left;i<nums.length;i++){
              // System.out.println(i);
              nums[i] = 0;
          }
          // System.out.println(nums);
      }
  }
  ```

  

##### [844.比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)

  ```java
  class Solution {
      public boolean backspaceCompare(String s, String t) {
      
          return backCompare(s).equals(backCompare(t));
     
          
      }
      private String backCompare(String s){
          int left = 0;
          char[] tmp = s.toCharArray();
  
          for (int right=0;right<s.length();right++){
              if (tmp[right] != '#'){
                  tmp[left] = tmp[right];
                  left++;
              }else if (left > 0){
                  left--;
              }
          }
          return new String(tmp,0,left);
      }
  }
  ```

  

##### [977.有序数组的平方(opens new window)](https://leetcode.cn/problems/squares-of-a-sorted-array/)

  ```java
  import java.util.ArrayList;
  import java.util.Arrays;
  import java.util.List;
  
  // 暴力解法
  class Solution {
      public int[] sortedSquares(int[] nums) {
          List<Integer> ans = new ArrayList<>();
          for (int i:nums){
              ans.add(i*i);
          }
          
          int[] anss = new int[nums.length];
          for (int i =0;i<nums.length;i++){
              anss[i] = ans.get(i);
          }
          Arrays.sort(anss);
          return anss;
      }
  }
  
  // 双指针解法
  public int[] sortedSquares(int[] nums) {
          int[] result = new int[nums.length];
          int left = 0;
          int right = nums.length - 1;
          int index = nums.length - 1;
          while (left <= right) {
              if (nums[left]*nums[left] > nums[right] * nums[right]){
                  result[index] = nums[left] * nums[left];
                  left++;
                  index--;
              }else{
                  result[index] = nums[right] * nums[right];
                  right--;
                  index--;
              }
          }
          return result;
  }
  ```

  

## 长度最小的子数组

##### 核心代码：LeetCode：209.长度最小的子数组

```java
// 滑动窗口
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int i = 0;
        int result = 1000000001;
        int sum = 0;
        for (int end=0;end<nums.length;end++){
            sum += nums[end];
            // 符合条件 - 持续移动
            while (sum >= target){
                int tmpLen = end - i + 1;
                result = Math.min(result, tmpLen);
                // 收缩区间
                sum -= nums[i];
                // 起始位置往前移
                i++;
            }
        }
        return result == 1000000001 ? 0 : result;
        
    }
}
```

相关题目：

##### [904.水果成篮](https://leetcode.cn/problems/fruit-into-baskets/)

  ```java
  import java.util.HashMap;
  import java.util.Map;
  
  class Solution {
      public int totalFruit(int[] fruits) {
          int slow = 0;
          int result = 0;
          Map<Integer, Integer> kinds = new HashMap<>();
          for (int end=0;end<fruits.length;end++){
              // 给种类进行计数
              kinds.put(fruits[end], kinds.getOrDefault(fruits[end], 0)+1);
              while (kinds.size() > 2){
                  // 种类大于2的时候清楚已经计算过的种类数
                  kinds.put(fruits[slow], kinds.get(fruits[slow])-1);
                  if (kinds.get(fruits[slow]) == 0){
                      // 将一个种类完全清除
                      kinds.remove(fruits[slow]);
                  }
                  slow++;
              }
              result = Math.max(result, end - slow + 1);
          }
          return result;
      }
  }
  ```

  

##### [76.最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

  ```java
  class Solution {
      public String minWindow(String s, String t) {
          int left = 0;
          int track = 0;
          int maxLen = Integer.MAX_VALUE;
          int start = 0;
          Map<Character, Integer> tCheck = new HashMap<>();
          Map<Character, Integer> sWindow = new HashMap<>();
  
          // 设置好t的字符出现的次数方便查询对比
          for (int i=0; i < t.length();i++){
              tCheck.put(t.charAt(i), tCheck.getOrDefault(t.charAt(i), 0)+1);
          }
  
          // 滑动窗口查找t中的字符在s里面出现的窗口
          for (int right=0; right<s.length();right++){
              // 首先判断找到符合标准的窗口大小
              char nums = s.charAt(right);
              if (tCheck.containsKey(nums)){
                  sWindow.put(nums, sWindow.getOrDefault(nums, 0)+1);
                  if (sWindow.get(nums).equals(tCheck.get(nums))){
                      track++; // 出现的次数匹配
                  }
              }
  
              while (track == tCheck.size()){
                  // 满足要求更新left收缩窗口
                  // 找到符合要求的区间长度
                  if (right - left + 1 < maxLen) {  // 使用if判断，只在找到更小窗口时更新
                      maxLen = right - left + 1;
                      start = left;
                  }
  
                  char tmp = s.charAt(left); // 区间内开始遍历
                  left++;
                  if (tCheck.containsKey(tmp)){
                      if (sWindow.get(tmp).equals(tCheck.get(tmp))){
                          track--;
                      }
                      sWindow.put(tmp, sWindow.get(tmp)-1);
                  }
              }
          
          }
          return maxLen == Integer.MAX_VALUE ? "" : s.substring(start, start+maxLen);
  
  
  
      }
  }
  ```

## 螺旋矩阵 II

##### 核心代码：LeetCode：59.螺旋矩阵 II

```java
class Solution {
    public int[][] generateMatrix(int n) {
        int startX = 0;
        int startY = 0;
        int offset = 1;
        int i = 0; // rows
        int j = 0; // cols
        int count = 1;
        int loop = 1;
        int nums[][] = new int[n][n];

        while (loop <= n/2){
            // top 
            for (j = startY; j < n - offset; j++){
                nums[startX][j] = count++; //  起始位置的rows往右边递增
                System.out.println(nums[startX][j]);
            }            

            // right 
            for (i = startX; i < n - offset; i++ ){
                nums[i][j] = count++;
            }

            // bottom
            for (;j > startY;j--){
                nums[i][j] = count++;
            }

            // left 
            for (;i > startX;i--){
                nums[i][j] = count++;
            }
            startX++;
            startY++;
            offset++;
            loop++;
        }
        if (n % 2 == 1){
            // 中心点
            nums[startX][startY] = count;
        }
        return nums;

    }
}
```

##### [54.螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

  ```java
  import java.util.ArrayList;
  import java.util.List;
  
  class Solution {
      public List<Integer> spiralOrder(int[][] matrix) {
          int offset = 1;
          int startX = 0;
          int startY = 0;
          int i = 0; // rows
          int j = 0; // cols
          List<Integer> nums = new ArrayList<>();
         
          int m = matrix.length; // rows
          int n = matrix[0].length; // cols
  
          int loop = Math.min(m, n) / 2;
  
          while ( loop > 0){
              // top
              for (j=startY; j< n - offset;j++){
                  nums.add(matrix[startX][j]);
              }   
              
              // right 
              for (i=startX; i< m - offset;i++){
                  nums.add(matrix[i][j]);
              }
  
              // bottom
              for (;j > startY; j--){
                  nums.add(matrix[i][j]);
              }
  
              // left
              for (;i > startX;i--){
                  nums.add(matrix[i][j]);
              }
              loop--;
              startX++;
              startY++;
              offset++;
  
          }
          // if (loop % 2 == 1){
          //     nums.add(matrix[startX][startY]);
          //     System.out.println(matrix[startX][startY]);
          // }
          if (Math.min(m, n) % 2 == 1) {
              if (m <= n) {
                  // 处理剩余的单行
                  for (int jj = startY; jj <= n - offset; jj++) {
                      nums.add(matrix[startX][jj]);
                  }
              } else {
                  // 处理剩余的单列
                  for (int ii = startX; ii <= m - offset; ii++) {
                      nums.add(matrix[ii][startY]);
                  }
              }
          }
          return nums;
      }
  }
  ```

  

##### [剑指Offer 29.顺时针打印矩阵](https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)

  ```java
  import java.util.ArrayList;
  import java.util.List;
  class Solution {
      public int[] spiralArray(int[][] array) {
          if (array == null || array.length == 0 || array[0].length == 0) {
              return new int[0];
          }        
          int offset = 1;
          int startX = 0;
          int startY = 0;
          int i = 0; // rows
          int j = 0; // cols
          List<Integer> nums = new ArrayList<>();
         
          int m = array.length; // rows
          int n = array[0].length; // cols
  
          int loop = Math.min(m, n) / 2;
  
          while ( loop > 0){
              // top
              for (j=startY; j< n - offset;j++){
                  nums.add(array[startX][j]);
              }   
              
              // right 
              for (i=startX; i< m - offset;i++){
                  nums.add(array[i][j]);
              }
  
              // bottom
              for (;j > startY; j--){
                  nums.add(array[i][j]);
              }
  
              // left
              for (;i > startX;i--){
                  nums.add(array[i][j]);
              }
              loop--;
              startX++;
              startY++;
              offset++;
  
          }
          // if (loop % 2 == 1){
          //     nums.add(matrix[startX][startY]);
          //     System.out.println(matrix[startX][startY]);
          // }
          if (Math.min(m, n) % 2 == 1) {
              if (m <= n) {
                  // 处理剩余的单行
                  for (int jj = startY; jj <= n - offset; jj++) {
                      nums.add(array[startX][jj]);
                  }
              } else {
                  // 处理剩余的单列
                  for (int ii = startX; ii <= m - offset; ii++) {
                      nums.add(array[ii][startY]);
                  }
              }
          }
          return nums.stream().mapToInt(Integer::intValue).toArray();
          
      }
  }
  
  ```

# 链表

#####  核心代码：LeetCode：59.螺旋矩阵 II

# 哈希表

## 有效的字母异位词

#####  核心代码：LeetCode：242.有效的字母异位词

  ```java
  class Solution {
      public boolean isAnagram(String s, String t) {
          int[] prev = new int[26];
          // int[] next = new int[26];
  
          for (int i=0;i<s.length();i++){
              prev[s.charAt(i) - 'a']++;
          }
  
          for (int j=0;j<t.length();j++){
              prev[t.charAt(j) - 'a']--;
          }
          
          for (int g=0;g<26;g++){
              if (prev[g] != 0){
                  return false;
              }
          }
          return true;
      }
  }
  ```

##### [383.赎金信](https://programmercarl.com/0383.赎金信.html)

  ```java
  class Solution {
      public boolean canConstruct(String ransomNote, String magazine) {
          int[] check = new int[26];
  
          for (int i=0;i<ransomNote.length();i++){
              check[ransomNote.charAt(i) - 'a']++;
          }
  
          for (int j=0;j<magazine.length();j++){
              check[magazine.charAt(j) - 'a']--;
          }
  
          for (int p=0;p<26;p++){
              if (check[p] > 0){
                  return false;
              }
          }
          return true;
      }
  }
  ```

  

##### [49.字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

  ```java
  import java.util.ArrayList;
  import java.util.Arrays;
  import java.util.HashMap;
  import java.util.HashSet;
  import java.util.List;
  import java.util.Map;
  import java.util.Set;
  
  class Solution {
      public List<List<String>> groupAnagrams(String[] strs) {
         Map<String, List<String>> store = new HashMap<>();
         for (String st : strs){
              String key;
              if (st.isEmpty()){
                  key = "";
              }else{
                  char[] tmp = st.toCharArray();
                  Arrays.sort(tmp);
                  key = new String(tmp);
              }
              store.computeIfAbsent(key, k -> new ArrayList<>()).add(st);
         }
  
         List<List<String>> oo = new ArrayList<>(store.values());
         return oo;
          
      }
  
      // private boolean checkSame(String check, String compareString){
      //     if (check.equals(compareString)){
      //         return true;
      //     }
      //     int[] store = new int[26];
          
      //     for (int i=0;i<check.length();i++){
      //         store[check.charAt(i)-'a']++;
      //     }
  
      //     for (int j=0;j<compareString.length();j++){
      //         store[compareString.charAt(j)-'a']--;
      //     }
  
      //     for (int u=0;u<26;u++){
      //         if (store[u] > 0){
      //             return false;
      //         }
      //     }
      //     return true;
      // }
  }
  ```

  

##### [438.找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

  ```java
  import java.util.ArrayList;
  import java.util.List;
  
  class Solution {
      public List<Integer> findAnagrams(String s, String p) {
          int left = 0;
          int right = 0;
          List<Integer> result = new ArrayList<>();
          // make table for p to check 
          // sliding window
          while (right < s.length()){
              right = left + p.length(); // 通过左移动 + 锁定窗口大小滑动
              if (right > s.length()){break;}
              String subString = s.substring(left, right);
  
              if (checkString(p, subString)){
                  result.add(left);
              }
              left++;
              // // check if valid 
              // while (checkString(p, subString) == true && right - left == p.length()){
              //     result.add(left);
              //     left++;
              //     subString = s.substring(left, right);
              // }
          }
          return result;
      }
  
      private Boolean checkString(String a, String b){
          int[] store = new int[26];
          
          for (int i = 0; i<a.length();i++){
              store[a.charAt(i)-'a']++;
          }
  
          for (int j=0; j<b.length();j++){
              store[b.charAt(j)-'a']--;
          }
  
          for (int l=0;l<26;l++){
              if (store[l] > 0){
                  return false;
              }
          }
          return true;
      }        
  }
  ```

  ## 两个数组的交集

  ##### 核心代码：LeetCode：349. 两个数组的交集

  ```java
  import java.util.HashSet;
  import java.util.Set;
  
  class Solution {
      public int[] intersection(int[] nums1, int[] nums2) {
          Set<Integer> check = new HashSet<>();
          Set<Integer> answer = new HashSet<>();
          for (Integer n : nums1){
              check.add(n);
          }
  
          for (Integer s : nums2){
              if (check.contains(s)){
                  answer.add(s);
              }
          }
  
          return answer.stream().mapToInt(a->a).toArray();
          
      }
  }
  ```

##### [350.两个数组的交集 II](https://leetcode.cn/problems/intersection-of-two-arrays-ii/)

  ```java
  import java.util.ArrayList;
  import java.util.List;
  
  class Solution {
      public int[] intersect(int[] nums1, int[] nums2) {
          int[] n1 = new int[1002];
          int[] n2 = new int[1002];
          List<Integer> ans = new ArrayList<>();
          
          for (int i : nums1){
              n1[i]++;
          }
  
          for (int j:nums2){
              n2[j]++;
          }
  
          for (int p=0;p<1002;p++){
              while (n1[p] > 0 && n2[p]>0){
                  ans.add(p);
                  n1[p]--;
                  n2[p]--;
              }
          }
          return ans.stream().mapToInt(a->a).toArray();
      }
  }
  ```

##### [202. 快乐数](https://leetcode.cn/problems/happy-number/)

  ```java
  import java.util.HashSet;
  import java.util.Set;
  
  class Solution {
      public boolean isHappy(int n) {
          int sum = 0;
          Set<Integer> record = new HashSet<>();
          while (!record.contains(n) && n != 1){
              record.add(n);
              n = getNext(n);
          }
          return n == 1;
      }
  
      private int getNext(int n){
          int sum = 0;
          while (n > 0) {
              sum += (n % 10) * (n % 10);
              n = n / 10;
          }
          return sum;
      }
  }
  ```

##### [1. 两数之和](https://leetcode.cn/problems/two-sum/)

  ```java
  import java.util.HashMap;
  import java.util.Map;
  
  class Solution {
      public int[] twoSum(int[] nums, int target) {
          Map<Integer, Integer> used = new HashMap<>();
          int[] answer = new int[2];
          for (int i = 0; i < nums.length; i++){
              int needs = target - nums[i];
              if (!used.containsKey(needs)){
                  used.put(nums[i], i);
              } else{
                  answer[0] = i;
                  answer[1] = used.get(needs);                
              }
          }
          return answer;
      }
  }
  ```

  

##### [454. 四数相加 II](https://leetcode.cn/problems/4sum-ii/)

  ```java
  import java.util.HashMap;
  import java.util.Map;
  
  class Solution {
      public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
          Map<Integer, Integer> prevUsed = new HashMap<>();
          for (Integer i : nums1){
              for (Integer j : nums2){
                  int prevSum = i + j;
                  prevUsed.put(prevSum, prevUsed.getOrDefault(prevSum, 0) + 1);
              }
          }
          int count = 0;
          for (Integer i1 : nums3){
              for (Integer j1 : nums4){
                  int afterSum = 0 - (i1 + j1);
                  if (prevUsed.containsKey(afterSum)){
                      count += prevUsed.getOrDefault(afterSum, 0);
                  }
              }
          }
          return count;
  
      }
  }
  ```

#####  [15. 三数之和](https://leetcode.cn/problems/3sum/)

  ```java
  import java.util.ArrayList;
  import java.util.Arrays;
  import java.util.List;
  
  class Solution {
      public List<List<Integer>> threeSum(int[] nums) {
          Arrays.sort(nums);
          int right = nums.length;
          List<List<Integer>> answer = new ArrayList<>();
  
          for (int i=0; i< right -2;i++) {
              if (i > 0 && nums[i] == nums[i-1]){
                  continue;
              }
              int l = i + 1;
              int r = right - 1;
  
              while (l < r) {
                  int sums = nums[i] + nums[l] + nums[r];
                  if (sums == 0){
                      List<Integer> tmp = new ArrayList<>();
                      tmp.add(nums[i]);
                      tmp.add(nums[l]);
                      tmp.add(nums[r]);
                      answer.add(tmp); 
  
                      while (l < r && nums[l] == nums[l+1]){
                          l++;
                      }
                      while (l < r && nums[r] == nums[r-1]){
                          r--;
                      }
                      l++;
                      r--;
                  }else if (sums > 0){
                      r--;
                  }else{
                      l++;
                  }
              }
          }
          return answer;
          
      }
  }
  ```

##### [18. 四数之和](https://leetcode.cn/problems/4sum/) 

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

class Solution {
    static public List<List<Integer>> fourSum(int[] nums, int target) {
        int fullLen = nums.length;
        List<List<Integer>> result = new ArrayList<>();

        Arrays.sort(nums);

        for (int k=0;k<fullLen;k++){
            // cut k due to -2 > -5
            if (nums[k] > target && nums[k] >= 0){
                break;
            }
            if (k > 0 && nums[k] == nums[k-1]){
                continue;
            }

            for (int i = k+1; i<fullLen;i++){
                // cut for i
                if (nums[i] + nums[k] > target && nums[i] + nums[k] >= 0){
                    break;
                }
                if (nums[i] == nums[i-1] && i > k + 1){
                    continue;
                }
                int left = i + 1;
                int right = fullLen - 1;
                while (left < right){
                    long sums = (long) nums[k] + nums[i] + nums[left] + nums[right];
                    if (sums > target){
                        right--;
                    }else if (sums < target){
                        left++;
                    }else{
                        List<Integer> tmp = new ArrayList<>();
                        tmp.add(nums[k]);
                        tmp.add(nums[i]);
                        tmp.add(nums[left]);
                        tmp.add(nums[right]);
                        result.add(tmp);

                        // remove duplication
                        while (left < right && nums[left] == nums[left+1]){
                            left++;
                        }
                        while (left < right && nums[right] == nums[right-1]){
                            right--;
                        }
                        left++;
                        right--;
                    }
                    // left++;
                    // right--;
                }
            }
        }
        return result;
    }
}
```



  ## 字符串

  ##### 核心代码：LeetCode：344. 反转字符串

```java
class Solution {
    public void reverseString(char[] s) {
        int fullLen = s.length;
        int left = 0;
        int right = fullLen - 1;
        while (left < right){
            char tmp = s[left];
            s[left] = s[right];
            s[right] = tmp;
            left++;
            right--;

        }
        
    }
}
```

